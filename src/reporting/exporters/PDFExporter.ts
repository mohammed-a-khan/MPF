import { Page, Browser, BrowserContext } from 'playwright';
import * as fs from 'fs/promises';
import * as path from 'path';
import { existsSync } from 'fs';
import * as crypto from 'crypto';
import { ReportData, PDFOptions, ExportResult, ExportFormat } from '../types/reporting.types';
import { ActionLogger } from '../../core/logging/ActionLogger';

export class PDFExporter {
  private browser: Browser | null = null;
  private context: BrowserContext | null = null;
  private tempDir: string;
  private logger = ActionLogger.getInstance();

  constructor() {
    this.tempDir = path.join(process.cwd(), '.temp', 'pdf-export');
  }

  async export(
    reportData: ReportData,
    htmlContent: string,
    options: PDFOptions = { format: ExportFormat.PDF }
  ): Promise<ExportResult> {
    const exportId = crypto.randomUUID();
    const startTime = Date.now();

    try {
      await this.logger.logAction('pdf-export-start', {
        target: 'report',
        status: 'info',
        exportId,
        options
      });

      await this.prepareExport();

      const tempHtmlPath = await this.createTempHtml(htmlContent, exportId);

      await this.launchBrowser();

      const outputPath = await this.generatePDFWithPlaywright(tempHtmlPath, reportData, options);

      const stats = await fs.stat(outputPath);

      const result: ExportResult = {
        success: true,
        filePath: outputPath,
        format: ExportFormat.PDF,
        size: stats.size,
        duration: Date.now() - startTime,
        metadata: {
          title: reportData.summary?.projectName || 'Test Report',
          author: 'CS Test Automation Framework',
          created: new Date().toISOString(),
          pages: 0,
          encrypted: false,
          optimized: true,
          hasTableOfContents: false,
          hasBookmarks: false,
          hasAttachments: false
        }
      };

      await this.logger.logAction('pdf-export-complete', {
        target: 'report',
        status: 'success',
        ...result
      });

      return result;

    } catch (error) {
      this.logger.logError('PDF export failed', error as Error);
      throw error;
    } finally {
      await this.cleanup();
    }
  }

  private async generatePDFWithPlaywright(
    htmlPath: string,
    reportData: ReportData,
    options: PDFOptions
  ): Promise<string> {
    if (!this.context) {
      throw new Error('Browser context not initialized');
    }

    const page = await this.context.newPage();

    try {
      await page.goto(`file://${htmlPath}`, { waitUntil: 'networkidle' });

      await this.waitForContentReady(page);

      const outputPath = path.join(
        options.outputDir || this.tempDir,
        options.filename || `test-report-${Date.now()}.pdf`
      );

      const pdfOptions: any = {
        path: outputPath,
        format: options.pageFormat || 'A4',
        printBackground: true,
        margin: {
          top: '1in',
          right: '1in',
          bottom: '1in',
          left: '1in'
        },
        displayHeaderFooter: options.displayHeaderFooter !== false,
        preferCSSPageSize: false,
        scale: options.scale || 1.0
      };

      if (options.displayHeaderFooter !== false) {
        pdfOptions.headerTemplate = options.headerTemplate || this.getDefaultHeader(reportData);
        pdfOptions.footerTemplate = options.footerTemplate || this.getDefaultFooter();
      }

      await page.pdf(pdfOptions);

      this.logger.info(`PDF generated successfully: ${outputPath}`);
      return outputPath;

    } finally {
      await page.close();
    }
  }

  private async waitForContentReady(page: Page): Promise<void> {
    try {
      await page.waitForTimeout(2000);

      await page.waitForFunction(() => {
        const images = Array.from(document.querySelectorAll('img'));
        return images.every(img => img.complete);
      }, { timeout: 10000 });

      await page.waitForFunction(() => {
        if (document.fonts) {
          return document.fonts.ready.then(() => true);
        }
        return true;
      }).catch(() => {
      });

    } catch (error) {
      this.logger.warn('Some content may not be fully loaded for PDF generation', error as Error);
    }
  }

  private getDefaultHeader(reportData: ReportData): string {
    const title = reportData.summary?.projectName || 'Test Report';
    const date = new Date().toLocaleDateString();
    
    return `
      <div style="font-size: 10px; padding: 5px 15px; width: 100%; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ccc;">
        <span style="font-weight: bold;">${title}</span>
        <span>${date}</span>
      </div>
    `;
  }

  private getDefaultFooter(): string {
    return `
      <div style="font-size: 10px; padding: 5px 15px; width: 100%; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #ccc;">
        <span>Generated by CS Test Automation Framework</span>
        <span>Page <span class="pageNumber"></span> of <span class="totalPages"></span></span>
      </div>
    `;
  }

  private async prepareExport(): Promise<void> {
    try {
      if (!existsSync(this.tempDir)) {
        await fs.mkdir(this.tempDir, { recursive: true });
      }
    } catch (error) {
      this.logger.error('Failed to prepare export environment', error as Error);
      throw error;
    }
  }

  private async createTempHtml(content: string, exportId: string): Promise<string> {
    const tempPath = path.join(this.tempDir, `report-${exportId}.html`);
    
    const enhancedHtml = await this.enhanceHtmlForPdf(content);
    
    await fs.writeFile(tempPath, enhancedHtml, 'utf8');
    return tempPath;
  }

  private async enhanceHtmlForPdf(html: string): Promise<string> {
    const pdfStyles = `
      <style>
        @media print {
          body { 
            -webkit-print-color-adjust: exact !important;
            color-adjust: exact !important;
            print-color-adjust: exact !important;
          }
          
          .cs-section {
            page-break-inside: avoid;
            break-inside: avoid;
          }
          
          .cs-card {
            page-break-inside: avoid;
            break-inside: avoid;
          }
          
          .cs-scenario {
            page-break-inside: avoid;
            break-inside: avoid;
          }
          
          h1, h2, h3, h4, h5, h6 {
            page-break-after: avoid;
            break-after: avoid;
          }
          
          .cs-navigation {
            display: none !important;
          }
          
          .cs-modal {
            display: none !important;
          }
          
          .cs-lightbox {
            display: none !important;
          }
        }
        
        @page {
          size: A4;
          margin: 20mm 15mm;
        }
      </style>
    `;

    return html.replace('</head>', `${pdfStyles}</head>`);
  }

  private async launchBrowser(): Promise<void> {
    try {
      // CRITICAL FIX: Use existing browser instead of launching new one
      const { BrowserManager } = await import('../../core/browser/BrowserManager');
      const browserManager = BrowserManager.getInstance();
      
      this.browser = await browserManager.getBrowser();
      if (!this.browser || !this.browser.isConnected()) {
        throw new Error('No active browser available for PDF generation');
      }

      this.context = await this.browser.newContext({
        viewport: { width: 1920, height: 1080 }
      });

      this.logger.info('Using existing browser for PDF generation - no new browser launched');
    } catch (error) {
      this.logger.error('Failed to use existing browser for PDF generation', error as Error);
      throw error;
    }
  }

  private async cleanup(): Promise<void> {
    try {
      if (this.context) {
        await this.context.close();
        this.context = null;
      }

      // CRITICAL FIX: Don't close the shared browser instance!
      if (this.browser) {
        this.browser = null;
      }

      try {
        const tempFiles = await fs.readdir(this.tempDir);
        for (const file of tempFiles) {
          if (file.startsWith('report-') && file.endsWith('.html')) {
            await fs.unlink(path.join(this.tempDir, file));
          }
        }
      } catch (error) {
      }

      this.logger.info('PDF export cleanup completed');
    } catch (error) {
      this.logger.warn('PDF export cleanup failed', error as Error);
    }
  }

  async exportBatch(
    reports: Array<{ data: ReportData; html: string; name?: string }>,
    options: PDFOptions = { format: ExportFormat.PDF }
  ): Promise<ExportResult> {
    const startTime = Date.now();
    
    try {
      const results: ExportResult[] = [];
      
      for (let i = 0; i < reports.length; i++) {
        const report = reports[i];
        if (!report) continue;
        
        const batchOptions = {
          ...options,
          filename: report.name ? `${report.name}.pdf` : `batch-report-${i + 1}.pdf`
        };
        
        const result = await this.export(report.data, report.html, batchOptions);
        results.push(result);
      }

      const totalSize = results.reduce((sum, r) => sum + (r?.size || 0), 0);
      
      return {
        success: true,
        filePath: options.outputDir || this.tempDir,
        format: ExportFormat.PDF,
        size: totalSize,
        duration: Date.now() - startTime,
        metadata: {
          title: 'Batch Export',
          author: 'CS Test Automation Framework',
          created: new Date().toISOString(),
          pages: 0,
          encrypted: false,
          optimized: true,
          hasTableOfContents: false,
          hasBookmarks: false,
          hasAttachments: false,
          batchCount: reports.length
        }
      };

    } catch (error) {
      this.logger.error('Batch PDF export failed', error as Error);
      throw error;
    }
  }
} 
